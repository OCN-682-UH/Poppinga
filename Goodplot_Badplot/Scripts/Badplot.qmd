---
title: "test"
format: 
  html: 
    theme: sandstone
---

### Load Libraries
```{r}
#| message: false
#| warning: false

library(tidyverse)
library(here)
library(ggplot2)
library(tidytuesdayR) # data
library(ghibli) # color palette I often use
library(beepr)
library(lubridate)
library(dplyr)
library(tidyr)
library(grid)  # for ggplot graphical object (Grob) insets
library(ggpp) # ggplot2 extension
library(gtable) # arranges grobs
library(scales) 
library(forcats) # lumping
library(png) # adding images
library(magick) 
library(cowplot)
```

### Read Data  
```{r}
#| message: false
#| warning: false

scoobydoo <- tt_load("2021-07-13") # loads Tidy Tuesday Scooby Doo data
tt <- tidytuesdayR::tt_load("2021-07-13")
scoobydoo_bad <- tt$scoobydoo %>% as_tibble() # get scooby doo data frame
# write.csv(scoobydoo_data, here("Goodplot-Badplot", "Data", "scoobydoo.csv"), row.names = FALSE) # save the data sheet
```



```{r}
# #| message: false
# #| warning: false
#| out-width: "100%"
#| fig-align: "center"
#| label: fig-scoobydoobad
#| fig-cap: "This is a figure showing a piechart of monster species with how many times scooby was captured and how many times shaggys was captured"
#| dev: "png"
#| fig-format: png

# CLEAN THE DATA

# Make a clean, single-species label per row (no heavy transforms)
# Number of gang members captured in each row (episode/monster)
captured_columns<-c("captured_scooby", "captured_shaggy", "captured_fred",
               "captured_daphnie", "captured_velma")

scooby_clean <- scoobydoo_bad %>%
  mutate(species_one = ifelse(is.na(monster_species), "Unknown", monster_species), # replace NA
    species_one = sub(",.*$", "", species_one),   # take text up to first comma
    species_one = trimws(species_one),  # trim spaces in data 
    captured_count = rowSums(across(all_of(captured_columns), ~ as.integer(as.character(.) %in% c("TRUE","True","true","Yes","yes","1"))),
      na.rm = TRUE))            

# Stuff to do for a PIE CHART
# Build pie counts with a small number of wedges LUMP -> COUNT -> DROP UNUSED LEVELS
k <- 6
pie_data <- scooby_clean %>%
  mutate(species_one = fct_lump_n(species_one, n = k, other_level = "Other")) %>% # lump
  count(species_one, name = "n") %>% # count after lumping
  mutate(pct = n / sum(n)) %>%
  arrange(desc(n)) %>%
  mutate(species_one = fct_drop(species_one)) # drop unused levels

# 3 wedges: the three most common species
species_top3<-head(pie_data$species_one, 3)

# compute where each wedge sits so we can drop insets *inside* it
pie_pos <- pie_data %>%
  mutate(end = cumsum(pct), #geometry of slices
    start = lag(end, default = 0),
    mid = (start + end) / 2, # middle of the slice in [0,1]
    theta = 2*pi*(0.25 - mid))  # 0 at top clockwise

# helper: normalized parent coords (npc) for a given species and radius r
npc_for <- function(species, r = 0.70) 
  {row <- pie_pos[match(species, pie_pos$species_one), ]
  tibble(x = 0.5 + r * cos(row$theta),
         y = 0.5 + r * sin(row$theta))}

# Keep only the *present* levels for legend/breaks
levels_keep <- levels(pie_data$species_one) # now just k (+ "Other")




# Three MINI PLOTS (one per chosen wedge)

# Theme for all mini plots:
mini_theme <- theme_void(base_size = 7) +
  theme(legend.position = "none",
    plot.background = element_rect(fill = "pink", color = "white", 0.6),
    panel.border = element_rect(fill = NA, color = "white", linewidth = 0.5),
    panel.background = element_rect(fill = "yellow", color = NA),
    plot.title = element_text(color = "white", hjust = 0, face = "bold", size = 7),
    plot.margin = margin(3, 3, 3, 3))

# Plot A: Boxplot- Number captured by monster_type (top 5 types for readability)
mini_monster_box <- scooby_clean %>%
  filter(species_one == species_top3[1]) %>%
  mutate(monster_type = fct_lump_n(monster_type, n = 5, other_level = "Other")) %>%
  ggplot(aes(monster_type, captured_count, fill = monster_type)) +
  geom_boxplot(width = 0.7, outlier.size = 0.6, colour = "black") +
  coord_flip() +
  labs(title = "Captures by monster type") +
  mini_theme

# Plot B: Bar Plot- Captured Shaggy
mini_shaggy_bar <- scooby_clean %>%
  filter(species_one == species_top3[2]) %>%
  mutate(shaggy_captured_label = case_when(
      as.character(captured_shaggy) %in% c("TRUE","True","true","Yes","yes","1")  ~ "Yes",
      as.character(captured_shaggy) %in% c("FALSE","False","false","No","no","0") ~ "No", TRUE ~ "Unknown"),
    shaggy_captured_label = factor(shaggy_captured_label, levels = c("Yes","No","Unknown"))) %>%
  count(shaggy_captured_label, name = "n") %>%
  ggplot(aes(shaggy_captured_label, n, fill = shaggy_captured_label)) +
  geom_col(width = 0.85, colour = "white") +
  labs(title = "Shaggy captured?") +
  mini_theme


# Plot C: Bar Plot- Captured Scooby
mini_captured_bar <- scooby_clean %>%
  filter(species_one == species_top3[3]) %>%
  mutate(captured_label = case_when(
    as.character(captured_scooby) %in% c("TRUE","True","true","Yes","yes","1")  ~ "Yes",
    as.character(captured_scooby) %in% c("FALSE","False","false","No","no","0") ~ "No",
    TRUE ~ "Unknown")) %>%
  count(captured_label, name = "n") %>%
  mutate(captured_label = forcats::fct_relevel(captured_label, "Yes","No","Unknown")) %>%
  ggplot(aes(captured_label, n, fill = captured_label)) +
  geom_col(width = 0.85, colour = "white") +
  labs(title = "Scooby captured?") +
  mini_theme

# make “legend versions” of two minis
mini_type_bar_leg <- mini_type_bar + theme(legend.position = "right") +
  guides(fill = guide_legend(title = "Type", ncol = 1))
mini_captured_bar_leg <- mini_captured_bar + 
  theme(legend.position = "right", legend.text = element_text(color = "white"),
        legend.title = element_text(color = "yellow", face = "bold")) +
  guides(fill = guide_legend(title = "Captured", ncol = 1))

legend_type <- gtable_filter(ggplotGrob(mini_type_bar_leg), "guide-box")
legend_captured <- gtable_filter(ggplotGrob(mini_captured_bar_leg), "guide-box")


# where to drop each mini-plot (center-ish, edge-ish, etc.)

pos_A <- npc_for(species_top3[1], r = 0.60) # smaller closer to center
pos_B <- npc_for(species_top3[2], r = 0.70) # mid radius
pos_C <- npc_for(species_top3[3], r = 0.62)  # closer to center

# ----------------------------
# 3) Base pie and compose with insets
# ----------------------------

# loud palette (since this is for a “bad plot” vibe), use Brewer if you prefer
# palette for exactly pie_data levels
pal_pie <- grDevices::rainbow(length(levels_keep), s = 1, v = 1)
pal_pie <- stats::setNames(pal_pie, levels_keep)  # name colors so mapping is explicit


p_pie <- ggplot(pie_data, aes(x = 1, y = pct, fill = species_one)) +
  geom_col(color = "white", width = 1) +
  coord_polar(theta = "y", start = pi/18, clip = "off") +   # <-- small rotation # clip=off allows inset overlap
  scale_fill_manual(values = pal_pie, breaks = levels_keep,  # only specific levels stay in legend, legend restricted to these
    labels = scales::label_wrap(16),
    name   = "Monster species!") +
  guides(fill = guide_legend(ncol = 3)) + # fewer rows, easier to read
  labs(
    title = "Scooby-Doo: Monster species piechart with inset plots!!!!!",
    subtitle = "Inset plots: monster type mix, run time distribution, Scooby captured???") +
  theme_void(base_size = 12) +
  theme(plot.title = element_text(color = "red", face = "italic", hjust = 0),
        aspect.ratio = 1, # square panel → larger circle
        plot.margin = margin(4, 8, 24, 8),   # tighter margins
        legend.position = "bottom",
        legend.box = "vertical",
        legend.key.size = grid::unit(6, "pt"),
        legend.text = element_text(color = "white"),
        legend.title = element_text(color = "yellow", face = "bold"),
        legend.background   = element_rect(fill = scales::alpha("#121418", 0.9), colour = NA),
        plot.title.position = "plot",
        plot.subtitle = element_text(color = "green", hjust = 0),
        plot.background = element_rect(fill = "#121418", color = NA),
        panel.background = element_rect(fill = "#121418", color = NA))

# compose: put each mini-plot *inside its wedge*
p_pie_layers<-p_pie +
  # in-wedge mini plots (smaller)
  geom_plot_npc(aes(npcx = pos_A$x, npcy = pos_A$y, label = list(mini_monster_box)),
                vp.width = 0.32, vp.height = 0.22) +
  geom_plot_npc(aes(npcx = pos_B$x, npcy = pos_B$y, label = list(mini_shaggy_bar)),
                vp.width = 0.30, vp.height = 0.20) +
  geom_plot_npc(aes(npcx = pos_C$x, npcy = pos_C$y, label = list(mini_captured_bar)),
                vp.width = 0.32, vp.height = 0.22) +
  # side legends — more off to the sides
  geom_grob_npc(aes(npcx = 0.1, npcy = 0.55, label = list(legend_type))) +     # left and below scooby plot
  geom_grob_npc(aes(npcx = 0.97, npcy = 0.86, label = list(legend_captured)))   # right and above monster plot

# adding the image
url<-"https://upload.wikimedia.org/wikipedia/en/b/be/Scooby-Doo_2_-_Monsters_Unleashed_poster.png"
tmp <- tempfile(fileext = ".png"); download.file(url, tmp, mode = "wb")
black_background<-rectGrob(gp = gpar(fill = "black", col = NA))

final_badplot<- ggdraw() +
  draw_grob(black_background, x = 0, y = 0, width = 2, height = 2) + # full black background
  draw_image(tmp, x = 0.2, y = 0.5, scale = 0.5, hjust = 0, vjust = 0.5) + # on the right side
  draw_plot(p_pie_layers, x = 0, y = 0, width = 0.72, height = 0.96) # pie, insets, side legends on the left

final_badplot
```


_Beep when the code is done running..._
```{r}
beep(10)
```



















```{r}
# #| message: false
#| eval: false

# CLEAN THE DATA

# 1) Make monster_status robustly from monster_real (whatever its type is)
# 0) Make a clean, single-species label per row (no heavy transforms)
scooby_clean <- scoobydoo_bad %>%
  mutate(species_one = ifelse(is.na(monster_species), "Unknown", monster_species), # replace NA
    species_one = sub(",.*$", "", species_one),   # take text up to first comma
    species_one = trimws(species_one))             # trim spaces in data 
  
# 1) Build pie counts with a small number of wedges LUMP -> COUNT -> DROP UNUSED LEVELS
K <- 6
pie_df <- scooby_clean %>%
  mutate(species_one = fct_lump_n(species_one, n = K, other_level = "Other")) %>%
  count(species_one, name = "n") %>%                 # count after lumping
  mutate(pct = n / sum(n)) %>%
  arrange(desc(n)) %>%
  mutate(species_one = fct_drop(species_one))        # <- IMPORTANT: drop unused levels

# choose 3 wedges: the three most common species
species_top3<-head(pie_df$species_one, 3)

# compute where each wedge sits so we can drop insets *inside* it
pie_pos <- pie_df %>%
  mutate(end   = cumsum(pct), #geometry of slices
    start = lag(end, default = 0),
    mid   = (start + end) / 2, # middle of the slice in [0,1]
    theta = 2*pi*(0.25 - mid))  # 0 at top (12 o'clock), clockwise


# helper: normalized parent coords (npc) for a given species and radius r
npc_for <- function(species, r = 0.70) 
  {row <- pie_pos[match(species, pie_pos$species_one), ]
  tibble(x = 0.5 + r * cos(row$theta),
         y = 0.5 + r * sin(row$theta))}

# Keep only the *present* levels for legend/breaks
levels_keep <- levels(pie_df$species_one)           # now just K (+ "Other")


# 2) Three tiny plots (one per chosen wedge)
# ----------------------------
# ---------- make mini-plots pop visually ----------
mini_theme <- theme_void(base_size = 7) +
  theme(legend.position = "none",
    plot.background = element_rect(fill = "pink", color = "white", 0.6),
    panel.border = element_rect(fill = NA, color = "white", linewidth = 0.5),
    panel.background = element_rect(fill = "yellow", color = NA),
    plot.title = element_text(color = "white", hjust = 0, face = "bold", size = 7),
    plot.margin = margin(3, 3, 3, 3))

# (A) bar of monster_type (discrete) — thicker bars + border
mini_type_bar <- scooby_clean %>%
  filter(species_one == species_top3[1]) %>%
  count(monster_type, name = "n") %>%
  slice_max(n, n = 5, with_ties = FALSE) %>%
  mutate(monster_type = fct_reorder(monster_type, n)) %>%
  ggplot(aes(monster_type, n, fill = monster_type)) +
  geom_col(width = 0.85, colour = "black") +
  coord_flip() +
  labs(title = "Top monster types!!") +
  mini_theme

# Plot B: Captured Shaggy Histogram
mini_captured_hist <- scooby_clean %>%
  filter(species_one == species_top3[2]) %>%
  mutate(shaggy_captured_label = case_when(
    as.character(captured_shaggy) %in% c("TRUE","True","true","Yes","yes","1")  ~ "Yes",
    as.character(captured_shaggy) %in% c("FALSE","False","false","No","no","0") ~ "No",
    TRUE ~ "Unknown")) %>%
  count(shaggy_captured_label, name = "n") %>%
  mutate(shaggy_captured_label = forcats::fct_relevel(shaggy_captured_label, "Yes","No","Unknown")) %>%
  ggplot(aes(shaggy_captured_label, n, fill = shaggy_captured_label)) +
  geom_col(width = 0.85, colour = "white") +
  labs(title = "Shaggy captured??") +
  mini_theme


# (C) bar of captured_scooby (discrete labels) — thicker bars + border
mini_captured_bar <- scooby_clean %>%
  filter(species_one == species_top3[3]) %>%
  mutate(captured_label = dplyr::case_when(
    as.character(captured_scooby) %in% c("TRUE","True","true","Yes","yes","1")  ~ "Yes",
    as.character(captured_scooby) %in% c("FALSE","False","false","No","no","0") ~ "No",
    TRUE ~ "Unknown"
  )) %>%
  count(captured_label, name = "n") %>%
  mutate(captured_label = forcats::fct_relevel(captured_label, "Yes","No","Unknown")) %>%
  ggplot(aes(captured_label, n, fill = captured_label)) +
  geom_col(width = 0.85, colour = "white") +
  labs(title = "Scooby captured?") +
  mini_theme

# make “legend versions” of two minis
mini_type_bar_leg <- mini_type_bar + theme(legend.position = "right") +
  guides(fill = guide_legend(title = "Type", ncol = 1))
mini_captured_bar_leg <- mini_captured_bar + 
  theme(legend.position = "right", legend.text = element_text(color = "white"),
        legend.title = element_text(color = "yellow", face = "bold")) +
  guides(fill = guide_legend(title = "Captured", ncol = 1))

leg_type     <- gtable_filter(ggplotGrob(mini_type_bar_leg), "guide-box")
leg_captured <- gtable_filter(ggplotGrob(mini_captured_bar_leg), "guide-box")


# where to drop each mini-plot (center-ish, edge-ish, etc.)

pos_A <- npc_for(species_top3[1], r = 0.60) # smaller closer to center
pos_B <- npc_for(species_top3[2], r = 0.70) # mid radius
pos_C <- npc_for(species_top3[3], r = 0.62)  # closer to center

# ----------------------------
# 3) Base pie and compose with insets
# ----------------------------

# loud palette (since this is for a “bad plot” vibe), use Brewer if you prefer
# palette for exactly pie_df levels
pal_pie <- grDevices::rainbow(length(levels_keep), s = 1, v = 1)
pal_pie <- stats::setNames(pal_pie, levels_keep)  # name colors so mapping is explicit


p_pie <- ggplot(pie_df, aes(x = 1, y = pct, fill = species_one)) +
  geom_col(color = "white", width = 1) +
  coord_polar(theta = "y", start = pi/18, clip = "off") +   # <-- small rotation # clip=off allows inset overlap
  scale_fill_manual(values = pal_pie, breaks = levels_keep,  # only specific levels stay in legend, legend restricted to these
    labels = scales::label_wrap(16),
    name   = "Monster species!") +
  guides(fill = guide_legend(ncol = 3)) + # fewer rows, easier to read
  labs(
    title = "Scooby-Doo: Monster species piechart with inset plots!!!!!",
    subtitle = "Inset plots: monster type mix, run time distribution, Scooby captured???"
  ) +
  theme_void(base_size = 12) +
  theme(plot.title = element_text(color = "red", face = "italic", hjust = 0),
        aspect.ratio = 1, # square panel → larger circle
        plot.margin = margin(4, 8, 24, 8),   # tighter margins
        legend.position = "bottom",
        legend.box = "vertical",
        legend.key.size = grid::unit(6, "pt"),
        legend.text = element_text(color = "white"),
        legend.title = element_text(color = "yellow", face = "bold"),
        legend.background   = element_rect(fill = scales::alpha("#121418", 0.9), colour = NA),
        plot.title.position = "plot",
        plot.subtitle = element_text(color = "green", hjust = 0),
        plot.background = element_rect(fill = "#121418", color = NA),
        panel.background = element_rect(fill = "#121418", color = NA))

# compose: put each mini-plot *inside its wedge*
p_pie_layers<-p_pie +
  # in-wedge mini plots (smaller)
  geom_plot_npc(aes(npcx = pos_A$x, npcy = pos_A$y, label = list(mini_type_bar)),
                vp.width = 0.32, vp.height = 0.22) +
  geom_plot_npc(aes(npcx = pos_B$x, npcy = pos_B$y, label = list(mini_captured_hist)),
                vp.width = 0.30, vp.height = 0.20) +
  geom_plot_npc(aes(npcx = pos_C$x, npcy = pos_C$y, label = list(mini_captured_bar)),
                vp.width = 0.32, vp.height = 0.22) +
  # side legends — more off to the sides
  geom_grob_npc(aes(npcx = 0.1, npcy = 0.55, label = list(leg_type))) +     # far left
  geom_grob_npc(aes(npcx = 0.97, npcy = 0.86, label = list(leg_captured)))   # far right

# adding the image
url<-"https://upload.wikimedia.org/wikipedia/en/b/be/Scooby-Doo_2_-_Monsters_Unleashed_poster.png"
tmp <- tempfile(fileext = ".png"); download.file(url, tmp, mode = "wb")
black_background<-rectGrob(gp = gpar(fill = "black", col = NA))

p_final<- ggdraw() +
  draw_grob(black_background, x = 0, y = 0, width = 2, height = 2) + # full black background
  draw_image(tmp, x = 0.2, y = 0.5, scale = 0.5, hjust = 0, vjust = 0.5) + # left gutter side
  draw_plot(p_pie_layers, x = 0, y = 0, width = 0.72, height = 0.96) # pie, insets, side legends on the right

p_final
```




```{r}
#| eval: false
# ============= 1) LOAD + NORMALIZE =============
tt <- tidytuesdayR::tt_load("2021-07-13")
scooby <- tt$scoobydoo %>% as_tibble() # get scooby doo data frame
# 1) Make monster_status robustly from monster_real (whatever its type is)

scooby <- scooby %>%
  # normalize columns that vary by source
  mutate(monster_status = dplyr::case_when(
      tolower(trimws(as.character(monster_real))) %in% c("true","t","1","real","yes","y")  ~ "Real",     # monster status as text
      tolower(trimws(as.character(monster_real))) %in% c("false","f","0","fake","no","n") ~ "Fake",
      TRUE ~ NA_character_),
      runtime_clean = coalesce(as.numeric(run_time), as.numeric(run_time)),
    # captured_scooby should be logical -> factor with labels
      .cap_txt = tolower(str_trim(as.character(captured_scooby))),
      captured_flag = case_when(.cap_txt %in% c("true","t","1","yes","y")  ~ TRUE,
      .cap_txt %in% c("false","f","0","no","n") ~ FALSE,
      is.na(captured_scooby)                    ~ NA,   # keep NA
      TRUE                                      ~ NA    # anything else → NA
    ),
    # Step 2: make a clean, ordered factor for plotting
    captured_scooby = factor(
      case_when(
        is.na(captured_flag) ~ "Unknown",
        captured_flag        ~ "Yes",
        !captured_flag       ~ "No"
      ),
      levels = c("Yes","No","Unknown")
    )
  ) %>%
  select(-.cap_txt, -captured_flag)   # tidy up helpers



# ============= 2) PIE DATA (monster_species) =============
# Keep top K species so wedges are big enough; lump the rest
K <- 6
scooby <- scooby %>%
  mutate(monster_species = fct_lump_n(monster_species, n = K, other_level = "Other"),
         monster_species = fct_explicit_na(monster_species, na_level = "Unknown"))

pie_df <- scooby %>%
  filter(!is.na(monster_species)) %>%
  count(monster_species, name = "n") %>%
  mutate(pct = n / sum(n)) %>%
  arrange(monster_species)

# Slice geometry to place insets inside wedges
pie_pos <- pie_df %>%
  mutate(
    end   = cumsum(pct),
    start = lag(end, default = 0),
    mid   = (start + end) / 2,             # slice middle in [0,1]
    theta = 2*pi*(0.25 - mid)              # put 0 at 12 o'clock, go clockwise
  )

# 2) Fix the pie-position mutate (assign to pct)
scoobydoo_pie_position <- scoobydoo_piedata %>%
  mutate(
    pct   = pct / sum(pct),
    end   = cumsum(pct),
    start = dplyr::lag(end, default = 0),
    mid   = (start + end) / 2,
    theta = 2*pi*(0.25 - mid),
    npc_x_r75 = 0.5 + 0.75*cos(theta),
    npc_y_r75 = 0.5 + 0.75*sin(theta)
  )

# Helper: npc coordinates for a species at radius r (0..1 from center)
npc_for_species <- function(species, r = 0.65) {
  row <- pie_pos[match(species, pie_pos$monster_species), ]
  tibble(x = 0.5 + r * cos(row$theta), y = 0.5 + r * sin(row$theta))
}

# Choose target species (the top ones) for insets
target_species <- levels(pie_df$monster_species) %>% head(K)  # includes "Other"/"Unknown" if in top K

# ============= 3) MINI-PLOT FACTORIES (INSIDE WEDGES) =============
# A) For a given species: tiny bar of monster_type (discrete)
mini_type_bar <- function(species) {
  scooby %>%
    filter(monster_species == species) %>%
    count(monster_type, sort = TRUE, name = "n") %>%
    slice_head(n = 4) %>%
    mutate(monster_type = fct_reorder(monster_type, n)) %>%
    ggplot(aes(monster_type, n, fill = monster_type)) +
    geom_col(width = 0.8) +
    coord_flip() +
    theme_void(base_size = 6) +
    theme(legend.position = "none")
}

# B) For a given species: tiny bar of captured_scooby (logical factor)
mini_captured_bar <- function(species) {
  scooby %>%
    filter(monster_species == species) %>%
    count(captured_scooby, name = "n") %>%
    mutate(captured_scooby = fct_relevel(captured_scooby, "Yes", "No", "Unknown")) %>%
    ggplot(aes(captured_scooby, n, fill = captured_scooby)) +
    geom_col(width = 0.8) +
    theme_void(base_size = 6) +
    theme(legend.position = "none")
}

# C) For a given species: tiny histogram of runtime (continuous)
mini_runtime_hist <- function(species) {
  scooby %>%
    filter(monster_species == species, !is.na(runtime_clean)) %>%
    ggplot(aes(runtime_clean)) +
    geom_histogram(bins = 12, fill = "tomato", colour = "white") +
    theme_void(base_size = 6)
}

# ============= 4) BASE PIE =============
set.seed(42)
# loud palette for the pie (badplot energy—but you can swap to Brewer if you like)
n_cols <- n_distinct(pie_df$monster_species)
pie_pal <- grDevices::rainbow(n_cols, s = 1, v = 1,
                              start = 0, end = max(1, n_cols - 1) / n_cols, alpha = 1)

p_pie <- ggplot(pie_df, aes(x = 1, y = pct, fill = monster_species)) +
  geom_col(color = "white", width = 1) +
  coord_polar(theta = "y", clip = "off") +
  scale_fill_manual(values = pie_pal, name = "Monster species") +
  labs(
    title = "Scooby-Doo: Monster species pie with inset summaries",
    subtitle = "Insets show monster type mix, Scooby captured? frequency, and runtime distribution by species",
    x = NULL, y = NULL
  ) +
  theme_void(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.position = "bottom",
    legend.box = "vertical",
    plot.margin = margin(10, 20, 26, 10)
  )

# ============= 5) ADD MULTIPLE INSETS INTO SPECIFIC WEDGES =============
# We’ll place THREE insets for the first two species (to show the idea),
# and ONE inset for the remaining species so the figure doesn’t get too crowded.
layers <- list()
r_inner  <- 0.52   # near the center
r_middle <- 0.68   # middle of wedge
r_outer  <- 0.80   # near the rim

for (i in seq_along(target_species)) {
  sp <- target_species[i]

  # Build the mini-plots for this species
  p_type <- mini_type_bar(sp)
  p_cap  <- mini_captured_bar(sp)
  p_run  <- mini_runtime_hist(sp)

  # Compute three candidate positions on this wedge
  pos_inner  <- npc_for_species(sp, r = r_inner)
  pos_middle <- npc_for_species(sp, r = r_middle)
  pos_outer  <- npc_for_species(sp, r = r_outer)

  # Add layers: for first two species, place three insets; otherwise one inset
  if (i <= 2) {
    layers <- append(layers, list(
      geom_plot_npc(aes(npcx = pos_inner$x,  npcy = pos_inner$y,  label = list(p_type)),
                    vp.width = 0.46, vp.height = 0.32),
      geom_plot_npc(aes(npcx = pos_middle$x, npcy = pos_middle$y, label = list(p_cap)),
                    vp.width = 0.40, vp.height = 0.28),
      geom_plot_npc(aes(npcx = pos_outer$x,  npcy = pos_outer$y,  label = list(p_run)),
                    vp.width = 0.42, vp.height = 0.28)
    ))
  } else {
    layers <- append(layers, list(
      geom_plot_npc(aes(npcx = pos_middle$x, npcy = pos_middle$y, label = list(p_type)),
                    vp.width = 0.44, vp.height = 0.30)
    ))
  }
}

# Draw it: base pie + all inset layers
p_pie + layers
```







Old version thats meh:  
```{r}
#| eval: false
#| message: false
#| warning: false
#| out-width: "70%"
#| fig-align: "center"
#| label: fig-scoobydoo
#| fig-cap: "This is a figure showing ____."
#| echo: false
#| include: true
#| eval: true
#| dev: "png"
#| fig-format: png
# extract a tibble for tidy tuesday data
tt<- tidytuesdayR::tt_load("2021-07-13") # tt_data list, being explicit about where it is coming from
scoobydoo<- tt$scoobydoo %>% # get scooby doo data frame
as_tibble()

scoobydoo<-scoobydoo %>%
  mutate(monster_status = ifelse(monster_real, "Real", "Fake")) # fix Tidy Tuesday monster_status column from TRUE/FALSE to "Real" and "Fake"

# Edit the data for base pie chart (monster real vs fake)
scoobydoo_piedata<-scoobydoo %>%
  filter(!is.na(monster_status)) %>% # keep rows that have monster_status, label for each row
  count(monster_status) %>% # count Real and Fake monsters
  mutate(pct = n / sum(n)) # proportion for the pie wedges (must sum to 100% (1))

# pie data and the slices for positioning of inset charts
scoobydoo_pie_position<-scoobydoo_piedata %>%
  mutate(pct/sum(pct), end = cumsum(pct), # stuff to make slices
         start = lag(end, default = 0),
         mid = (start + end)/2, # middle of slice
         theta = 2*pi*(0.25 - mid), # 0.25 puts 0 at top
         npc_x_r75 = 0.5 + 0.75*cos(theta), # get npc coordinates on pie and radius r
         npc_y_r75 = 0.5 + 0.75*sin(theta))

npc_for <- function(label, r = 0.65) # npc coordinatess for a named slice
  {row <- scoobydoo_pie_position %>% slice(which(monster_status == label)[1])
  tibble(x = 0.5 + r * cos(row$theta), y = 0.5 + r * sin(row$theta))}


# Edit the data for a bar chart inside the pie chart (top networks by episode count)
scoobydoo_bardata <- scoobydoo %>%
  count(network, sort = TRUE) %>% # count episodes by network
  slice_head(n = 8) %>% # keep the top 8 for readability
  mutate(network = fct_reorder(network, n)) # reorder factor levels by count so the bar chart is sorted

# make a rainbow palette correctly for the bar plot fill
# this is NOT color blind friendly
n_cols_bar <- n_distinct(scoobydoo_bardata$network)
bar_palette <- grDevices::rainbow(n = n_cols_bar, s = 1, v = 1,
                                  start = 0, end = max(1, n_cols_bar - 1) / n_cols_bar, alpha = 1)

# Smaller plots to put within
scoobydoo_hist <- ggplot(scoobydoo, aes(run_time)) + # episode runtime data
  geom_histogram(bins = 12, fill = "tomato", color = "white") +
  theme_void(base_size = 6) + # font size
  theme(legend.position = "none")

scoobydoo_bar <- ggplot(scoobydoo_bardata, aes(network, n, fill = network)) + # network data
  geom_col() +
  coord_flip() + # flip x and y
  scale_fill_manual(values = bar_palette) +
  theme_void(base_size = 6) +
  theme(legend.position = "none")
  
# choose which slice gets which inset (edit the labels to your levels)
scoobydoo_positionhist<-npc_for("Fake", r = 0.55) # put histogram into the "Fake" slice
scoobydoo_positionbar<-npc_for("Real", r = 0.75) # put bar near edge of "Real" slice

# Pie Chart Background (Base)
scoobydoo_pie <- ggplot(scoobydoo_piedata,
                        aes(x = 1, y = pct, fill = monster_status)) + # monster data
  geom_col(color = "white", width = 1) +
  coord_polar(theta = "y", clip = "off") + # clip off so insets can spill out
  scale_fill_brewer(palette = "Paired", name = "Is the monster actually real???") + # bad choice on purpose, not color blind friendly
  labs(title = "Scooby Doo Mystery OutComeS!!!!!!",
       subtitle = "A pie chart because… why not??????",
       x = NULL, y = NULL) +
  theme_void(base_size = 12) +
  theme(plot.title = element_text(color = "red", face = "italic"),
        legend.position = "bottom", # move pie legend off the chart
        legend.box = "vertical", 
        plot.background = element_rect(fill = "grey95", color = NA),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = scales::alpha("white", 0.85),
                                     colour = NA),
        plot.margin = margin(t = 8, r = 24, b = 24, l = 8)) # room for legend

# Put small plots inside the pie 
# coordinates in piechart's data space
# x ≈ 1 is center, y is radial ~[0,1]
scoobydoo_pie +
  geom_plot_npc(aes(npcx = scoobydoo_positionhist$x, npcy = scoobydoo_positionhist$y, 
                    label =  list(scoobydoo_hist)), # histogram into "Fake" slice
                vp.width = 0.55, vp.height = 0.55) + # center coordinates and resize
  geom_plot_npc(aes(npcx = scoobydoo_positionbar$x, npcy = scoobydoo_positionbar$y, 
                    label =  list(scoobydoo_bar)), # histogram into "Fake" slice
                vp.width = 0.48, vp.height = 0.34)
```


Old version where legends cover the plot:  
```{r}
#| eval: false
# extract a tibble for tidy tuesday data
tt<- tidytuesdayR::tt_load("2021-07-13") # tt_data list, being explicit about where it is coming from
scoobydoo<- tt$scoobydoo %>% # get scooby doo data frame
as_tibble()

scoobydoo<-scoobydoo %>%
  mutate(monster_status = ifelse(monster_real, "Real", "Fake")) # fix Tidy Tuesday monster_status column from TRUE/FALSE to "Real" and "Fake"

# Edit the data for base pie chart (monster real vs fake)
scoobydoo_piedata<-scoobydoo %>%
  filter(!is.na(monster_status)) %>% # keep rows that have monster_status, label for each row
  count(monster_status) %>% # count Real and Fake monsters
  mutate(pct = n / sum(n)) # proportion for the pie wedges (must sum to 100% (1))

# Edit the data for a bar chart inside the pie chart (top networks by episode count)
scoobydoo_bardata <- scoobydoo %>%
  count(network, sort = TRUE) %>% # count episodes by network
  slice_head(n = 8) %>% # keep the top 8 for readability
  mutate(network = fct_reorder(network, n)) # reorder factor levels by count so the bar chart is sorted
  
# Pie Chart Background (Base)
scoobydoo_pie <- ggplot(scoobydoo_piedata,
                        aes(x = 1, y = pct, fill = monster_status)) + # monster data
  geom_col(color = "white", width = 1) +
  coord_polar(theta = "y", clip = "off") + # clip off so insets can spill out
  scale_fill_brewer(palette = "Paired", name = "Is the monster actually real???") + # bad choice on purpose, not color blind friendly
  labs(title = "Scooby Doo Mystery OutComeS!!!!!!",
       subtitle = "A pie chart because… why not??????",
       x = NULL, y = NULL) +
  theme_void(base_size = 12) +
  theme(plot.title = element_text(color = "red", 
                                  face = "italic"),
        legend.position = c(0.86, 0.78), # move legend and make it readable, inside top-right
        plot.background = element_rect(fill = "grey95", 
                                       color = NA),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = scales::alpha("white", 0.85),
                                     colour = NA),
        plot.margin = margin(t = 8, r = 24, b = 8, l = 8)) # room for legend

# Smaller plots to put within
scoobydoo_hist <- ggplot(scoobydoo, aes(run_time)) + # episode runtime data
  geom_histogram(bins = 12, fill = "tomato", color = "white") +
  theme_void(base_size = 6) + # font size
  theme(legend.position = "none")

scoobydoo_bar_legend <- ggplot(scoobydoo_bardata, aes(network, n, fill = network)) + # network data
  geom_col() +
  coord_flip() # flip x and y
  theme_void(base_size = 6) +
  theme(legend.position = "bottom")
  
bar_legend<-gtable_filter(ggplotGrob(scoobydoo_bar_legend), "guide-box") # legend grob, need to do otherwise legend is on top of pie chart
scoobydoo_bar<-scoobydoo_bar_legend +
  theme(legend.position = "none") # make bar plot inside have no legend

# turn it into graphical object ("grob")
scoobydoo_grobhist <- ggplotGrob(scoobydoo_hist) 
scoobydoo_grobbar  <- ggplotGrob(scoobydoo_bar)


# Put small plots *onto* the pie 
# coordinates in piechart's data space
# x ≈ 1 is center, y is radial ~[0,1]
scoobydoo_pie +
  geom_grob_npc(aes(npcx = 0.5, npcy = 0.5, label =  list(scoobydoo_grobhist)), # inset graphical objects
                vp.width = 0.6, vp.height = 0.6) + # center coordinates and resize
  geom_grob_npc(aes(npcx = 0.5, npcy = 0.5, label = list(scoobydoo_grobbar)),
                vp.width = 0.6, vp.height = 0.6) +
  geom_grob_npc(aes(npcx = 0.08, npcy = 0.50, label = list(bar_legend)))
```





(grob = scoobydoo_grobhist,
                    xmin = 0.2, xmax = 1.8,    # left–right placement
                    ymin = -0.28, ymax = 0.28) + # center hole
  ggpp::annotation_custom2(grob = scoobydoo_grobbar,
                    xmin = 0.35, xmax = 1.65, # inset near edge
                    ymin = 0.55, ymax = 0.95)
                    
  
  
**Edit the Data**  
```{r}
#| message: false
#| warning: false

# extract a tibble for tidy tuesday data
tt<- tidytuesdayR::tt_load("2021-07-13") # tt_data list, being explicit about where it is coming from
scoobydoo<- tt$scoobydoo %>% # get scooby doo data frame
as_tibble()

scoobydoo<-scoobydoo %>%
  mutate(monster_status = ifelse(monster_real, "Real", "Fake")) # fix Tidy Tuesday monster_status column from TRUE/FALSE to "Real" and "Fake"

# Edit the data for base pie chart (monster real vs fake)
scoobydoo_piedata<-scoobydoo %>%
  filter(!is.na(monster_status)) %>% # keep rows that have monster_status, label for each row
  count(monster_status) %>% # count Real and Fake monsters
  mutate(pct = n / sum(n)) # proportion for the pie wedges (must sum to 100% (1))

# pie data and the slices for positioning of inset charts
scoobydoo_pie_position<-scoobydoo_piedata %>%
  mutate(pct/sum(pct), end = cumsum(pct), # stuff to make slices
         start = lag(end, default = 0),
         mid = (start + end)/2, # middle of slice
         theta = 2*pi*(0.25 - mid), # 0.25 puts 0 at top
         npc_x_r75 = 0.5 + 0.75*cos(theta), # get npc coordinates on pie and radius r
         npc_y_r75 = 0.5 + 0.75*sin(theta))

npc_for <- function(label, r = 0.65) # npc coordinatess for a named slice
  {row <- scoobydoo_pie_position %>% slice(which(monster_status == label)[1])
  tibble(x = 0.5 + r * cos(row$theta), y = 0.5 + r * sin(row$theta))}


# Edit the data for a bar chart inside the pie chart (top networks by episode count)
scoobydoo_bardata <- scoobydoo %>%
  count(network, sort = TRUE) %>% # count episodes by network
  slice_head(n = 8) %>% # keep the top 8 for readability
  mutate(network = fct_reorder(network, n)) # reorder factor levels by count so the bar chart is sorted

# make a rainbow palette correctly for the bar plot fill
n_cols_bar <- n_distinct(scoobydoo_bardata$network)
bar_palette <- grDevices::rainbow(n = n_cols_bar, s = 1, v = 1,
                                  start = 0, end = max(1, n_cols_bar - 1) / n_cols_bar, alpha = 1)
```


**Make the Plots**  
```{r}
#| eval: false
#| message: false
#| warning: false
#| out-width: "70%"
#| fig-align: "center"
#| label: fig-scoobydoo
#| fig-cap: "This is a figure showing ____."
#| echo: false
#| include: true
#| eval: true
#| dev: "png"
#| fig-format: png

# Smaller plots to put within
scoobydoo_hist <- ggplot(scoobydoo, aes(run_time)) + # episode runtime data
  geom_histogram(bins = 12, fill = "tomato", color = "white") +
  theme_void(base_size = 6) + # font size
  theme(legend.position = "none")

scoobydoo_bar <- ggplot(scoobydoo_bardata, aes(network, n, fill = network)) + # network data
  geom_col() +
  coord_flip() + # flip x and y
  scale_fill_manual(values = bar_palette) +
  theme_void(base_size = 6) +
  theme(legend.position = "none")
  
# choose which slice gets which inset (edit the labels to your levels)
scoobydoo_positionhist<-npc_for("Fake", r = 0.55) # put histogram into the "Fake" slice
scoobydoo_positionbar<-npc_for("Real", r = 0.75) # put bar near edge of "Real" slice

# Pie Chart Background (Base)
scoobydoo_pie <- ggplot(scoobydoo_piedata,
                        aes(x = 1, y = pct, fill = monster_status)) + # monster data
  geom_col(color = "white", width = 1) +
  coord_polar(theta = "y", clip = "off") + # clip off so insets can spill out
  scale_fill_brewer(palette = "Paired", name = "Is the monster actually real???") + # bad choice on purpose, not color blind friendly
  labs(title = "Scooby Doo Mystery OutComeS!!!!!!",
       subtitle = "A pie chart because… why not??????",
       x = NULL, y = NULL) +
  theme_void(base_size = 12) +
  theme(plot.title = element_text(color = "red", face = "italic"),
        legend.position = "bottom", # move pie legend off the chart
        legend.box = "vertical", 
        plot.background = element_rect(fill = "grey95", color = NA),
        legend.justification = c(1, 1),
        legend.background = element_rect(fill = scales::alpha("white", 0.85),
                                     colour = NA),
        plot.margin = margin(t = 8, r = 24, b = 24, l = 8)) # room for legend

# Put small plots inside the pie 
# coordinates in piechart's data space
# x ≈ 1 is center, y is radial ~[0,1]
scoobydoo_pie +
  geom_plot_npc(aes(npcx = scoobydoo_positionhist$x, npcy = scoobydoo_positionhist$y, 
                    label =  list(scoobydoo_hist)), # histogram into "Fake" slice
                vp.width = 0.55, vp.height = 0.55) + # center coordinates and resize
  geom_plot_npc(aes(npcx = scoobydoo_positionbar$x, npcy = scoobydoo_positionbar$y, 
                    label =  list(scoobydoo_bar)), # histogram into "Fake" slice
                vp.width = 0.48, vp.height = 0.34)
```
                    
                    
                    
                    
