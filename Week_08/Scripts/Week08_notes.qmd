---
title: "Week 08 Lectures"
author: "Haley Poppinga"
format: 
  html:
    toc: true
    theme: sandstone
---

## Week 8a Lecture: Working with Words

[Lecture Slides](https://raw.githack.com/OCN-682-UH/Fall_2025/main/Week_08/15_Strings.html#1)  
[Required Reading r4ds](https://r4ds.hadley.nz/strings.html)  


### Introduction  

**Outline of class**  

Working with words  

* Using {stringr} to clean up strings (part of tidyverse)  
* Intro to regex (regular expressions)  
* Using {tidytext} for text mining/analysis  
* Make a wordcloud  


### Load Libraries  

```{r}
library(here)
library(tidyverse)
library(lubridate)
library(dplyr)
library(tidyr)
library(ggplot2)
library(tidytext)
library(wordcloud2)
library(janeaustenr)
```
Note: "stopwords" package doesn't have to be loaded in libraries, only installed onto computer.  


#### Intro to {stringr}  

**What is a string?**  

A string and a character are the same thing. You can tell something is a string by the presence of quotations. For example:  
```{r}
words<-"This is a string"
words
```

You can also have several strings in a vector.  
```{r}
words_vector<-c("Apples", "Bananas","Oranges")
words_vector
```

There are 4 basic families of functions in the {stringr} package:  

* Manipulation: these functions allow you to manipulate individual characters within the strings in character vectors.  
* Whitespace tools to add, remove, and manipulate whitespace.  
* Locale sensitive operations whose operations will vary from locale to locale.  
* Pattern matching functions. These recognize four engines of pattern description. The most common is regular expressions, but there are three other tools.  

**Manipulation**  

Paste words together. This can be useful if say you have a two columns of treatments and you want to combine them into one (e.g., high temp, low temp and high pH, low pH).  

Examples:  
Now it is one sentence as opposed to two sentences.  
```{r}
paste("High temp", "Low pH")
```


Add a dash in between the words  
```{r}
paste("High temp", "Low pH", sep = "-")
```

Remove the space in between the words. 
```{r}
paste0("High temp", "Low pH")
```

Working with vectors  
```{r}
shapes <- c("Square", "Circle", "Triangle")
paste("My favorite shape is a", shapes) # shapes is not in quotes because it is an object
```
For example, if creating multiple site names. "My site is", sites  


```{r}
two_cities <- c("best", "worst")
paste("It was the", two_cities, "of times.")
```
This is very useful when making labels for your plots.  
Can use this with mutate(new_treatment = paste("Treatment_A", "Treatment_B")) to change columns.  


**Manipulation: individual characters**  
Let's say you want to know how long a string is:  
```{r}
shapes # vector of shapes
```

```{r}
str_length(shapes) # how many letters are in each word?
```

Let's say you want to extract specific characters. Do you work with sequence data? This could be super useful to exact specific bases in a sequence.  
```{r}
seq_data<-c("ATCCCGTC")
str_sub(seq_data, start = 2, end = 4) # extract the 2nd to 4th AA
```
sub = subset, extracts 2nd to 4th.



You can also modify strings. 
```{r}
str_sub(seq_data, start = 3, end = 3) <- "A" # add an A in the 3rd position
seq_data
```
Allows for infinity number of replacements.  



You can also duplicate patterns in your strings. Here I am duplicating it 2 and 3 times  
```{r}
str_dup(seq_data, times = c(2, 3)) # times is the number of times to duplicate each string
```
Take sequence data and duplicate it 2 times and then 3 times  



#### Whitespace  

Say you have a column and you did not copy and paste your treatments like you learned in the first week of class. You now have some words with extra white spaces and R thinks its an entirely new word. Here is how to deal with that...  
```{r}
badtreatments<-c("High", " High", "High ", "Low", "Low")
badtreatments
```
There's spaces in the column, this is a great way to get rid of that.  


Remove white space.  
```{r}
str_trim(badtreatments) # this removes whitespace on both left and right hand side
```


You can also just remove from one side or the other.  
```{r}
str_trim(badtreatments, side = "left") # this removes left
```

The opposite of str_trim is str_pad, to add white space to either side  
```{r}
str_pad(badtreatments, 5, side = "right") # add a white space to the right side after the 5th character
```




add a character instead of white space  
```{r}
str_pad(badtreatments, 5, side = "right", pad = "1") # add a 1 to the right side after the 5th character
```
Use str_trim first then use str_pad. E.g. to add a bunch of zeros to a row in data.  

**Locale sensitive**  
Important, these will perform differently in different places in the world/with different languages. The default is English, but you can set the language setting.  

If there's upper and lower cases in data.  

Make everything All caps (upper case)  
```{r}
x<-"I love R!"
str_to_upper(x)
```

Make it lower case.  
```{r}
str_to_lower(x)
```

Make it title case (Cap first letter of each word)  
```{r}
str_to_title(x)
```


**Pattern matching**   
{stringr} has functions to view, detect, locate, extract, match, replace, and split strings based on specific patterns.  

View a specific pattern in a vector of strings.  
```{r}
data<-c("AAA", "TATA", "CTAG", "GCTT")
```

```{r}
# find all the strings with an A
str_view(data, pattern = "A")
```
Views it on your computer but doesn't save anything.  


Detect a specific pattern  
```{r}
str_detect(data, pattern = "A")
```
for logicals  


```{r}
str_detect(data, pattern = "AT")
```

Locate a pattern. 
```{r}
str_locate(data, pattern = "AT")
```
Locate where AT is in the sequence.  




#### regex: regular expressions  

Print out cheat sheet on desk to use it:  
[Cheat sheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)  
[Another Cheat sheet](https://rstudio.github.io/cheatsheets/regex.pdf)  

But, what if we want to search for something more complicated than that... like find all the numbers, letters, or special characters.  

Regular expressions are hard and a pain in the butt... but, are very helpful to learn.  

Actual image of my trying to use regex...  

There are several types of regular expressions:  

* Metacharacters  
* Sequences  
* Quantifiers  
* Character classes  
* POSIX character classes (Portable Operating System Interface)  

**Metacharacters**  
Metacharacters: The simplest form of regular expressions are those that match a single character. Most characters, including all letters and digits, are regular expressions that match themselves. For a language like R, there are some special characters that have reserved meaning and they are referred to as ‘Metacharacters”. The metacharacters in Extended Regular Expressions (EREs) are:  

. *\* | ( ) [ { $ * + ?  

[Metacharacters](https://d2o2utebsixu4k.cloudfront.net/tutorials/topics/images/1568271038916-image6.jpg)

Use *\\* to escape  
Use | to say "or"  


Let's say that you have the following set of strings...  
```{r}
vals<-c("a.b", "b.c","c.d")
```

And you want to replace all the "." with a space. Here is how you would do it:  
```{r}
#string, pattern, replace
str_replace(vals, "\\.", " ")
```


**Aside about the functions**  
Each function in {stringr} has two forms a basic form that searches for the first instance of a character and a *_all that searches for all instances. For example:  

Let's say we had multiple "." in our character vector  
```{r}
vals<-c("a.b.c", "b.c.d","c.d.e")
#string, pattern, replace
str_replace(vals, "\\.", " ")
```
This one only replaces the first one.  



str_replace only replaces the first instance. Let's try str_replace_all().  
```{r}
#string, pattern, replace
str_replace_all(vals, "\\.", " ")
```




**Sequences**  
Sequences, as the name suggests refers to the sequences of characters which can match. We have shorthand versions (or anchors) for commonly used sequences in R:  

[Sequences](https://d2o2utebsixu4k.cloudfront.net/tutorials/topics/images/1568271358029-image12.jpg)  
Find any string that has a number in it and any that doesn't for example.  

Let's subset the vector to only keep strings with digits  
```{r}
val2<-c("test 123", "test 456", "test")
str_subset(val2, "\\d")
```



**Character class**  
A character class or character set is a list of characters enclosed by square brackets [ ]. Character sets are used to match only one of the different characters. For example, the regex character class [aA] matches any lower case letter a or any upper case letter A.  

[Character class](https://d2o2utebsixu4k.cloudfront.net/tutorials/topics/images/1568271446941-image8.jpg)  
These are stackable.  


Let's count the number of lowercase vowels in each string
```{r}
str_count(val2, "[aeiou]")
```

```{r}
# count any digit
str_count(val2, "[0-9]")
```



**Quantifiers**  

symbol	Meaning  
^	      Beginning of String  
$	      End of String  
*\n*	  Newline (not the *)  
+	      One or More of Previous  
*	      Zero or More of Previous  
?	      Zero or One of Previous  
{5}	    Exactly 5 of Previous  
{2, 5}	Between 2 and 5 or Previous  
{2, }	  More than 2 of Previous  



Example: find the phone numbers  
```{r}
strings<-c("550-153-7578",
         "banana",
         "435.114.7586",
         "home: 672-442-6739")
```

Make a regex that finds all the strings that contain a phone number. We know there is a specific pattern (3 numbers, 3 numbers, 4 numbers and it can have either a "." or "-" to separate them). Let's also say we know that the first number cannot be a 1  
```{r}
phone <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
```
This is saying:  
Look for the number 2-9 in first digit.  
Look for any number x2. 
Look for a - or a .  
Look for any 3 and then 4 numbers.  
Called the regex, "phone".  


```{r}
# Which strings contain phone numbers?
str_detect(strings, phone)
```

Subset it so it deletes "banana"  
```{r}
# subset only the strings with phone numbers
test<-str_subset(strings, phone)
test
```


##### Think Pair Share  

Let's clean it up. Lets replace all the "." with "-" and extract only the numbers (leaving the letters behind). Remove any extra white space. You can use a sequence of pipes.  
```{r}
test %>% 
  str_replace_all("\\.", "-") %>%
  str_replace_all("[a-z]|\\:", "") %>% 
  str_trim()

```

Answer:  
```{r}
test %>%
  str_replace_all(pattern = "\\.", replacement = "-") %>% # replace periods with -
  str_replace_all(pattern = "[a-zA-Z]|\\:", replacement = "") %>% # remove all the things we don't want
  str_trim() # trim the white space
```
Don't need to add the "pattern = or replacement =".  



#### tidytext  

Package for text mining and making text tidy. This is very helpful for social sciences or anyone that uses survey data. Also, really helpful for text mining abstracts to write a review paper on a topic.  

Let's analyze a books by Jane Austen.  

The function to get all of the text from all of Jane Austen's books is austen_books()  

**DO NOT USE View() BECAUSE YOUR COMPUTER WILL CRASH!**   
```{r}
# explore it
head(austen_books())
```

```{r}
tail(austen_books())
```

Let's clean it up and add a column for line and chapter  
```{r}
original_books <- austen_books() %>% # get all of Jane Austen's books
  group_by(book) %>%
  mutate(line = row_number(), # find every line
         chapter = cumsum(str_detect(text, regex("^chapter [\\divxlc]", # count the chapters (starts with the word chapter followed by a digit or roman numeral)
                                                 ignore_case = TRUE)))) %>% #ignore lower or uppercase
  ungroup() # ungroup it so we have a dataframe again
# don't try to view the entire thing... its >73000 lines...
head(original_books)
```
cumulative sum
replacing whatever was on that line, analysis by chapter  
ignore_case shows that the whole regex( ) is an expression





Because we are interest in text mining, we will want to clean this so that there is only one word per row so its tidy. In tidytext each word is refered to as a token. The function to unnest the data so that its only one word per row is unnest_tokens().  
```{r}
tidy_books <- original_books %>%
  unnest_tokens(output = word, input = text) # add a column named word, with the input as the text column
head(tidy_books) # there are now >725,000 rows. Don't view the entire thing!
```
Output: what you want column name to be.  
Input: the text  



OK so we now have >735,000 rows of words.... but, some of these words are kind of useless. Words that are common and don't really have important meaning (e.g. "and","by","therefore"...). These are called stopwords. We can use the function "get_stopwords()" to essentially remove these words from our dataframe. (This function is essentially just a dataframe of unnecessary words)  
```{r}
#see an example of all the stopwords
head(get_stopwords())
```
Create our own set of stuff to exclude or include.  
A bunch of words we can say we dont care about and remove it from her books.  


Use what we know from joins to remove all the stopwords  
```{r}
cleaned_books <- tidy_books %>%
  anti_join(get_stopwords()) # dataframe without the stopwords
```
column was called "word" already so don't need to rename.  


```{r}
head(cleaned_books)
```

Let's count the most common words across all her books  
```{r}
cleaned_books %>% # clean books data frame, pipe to count word column
  count(word, sort = TRUE)
```
Example of when to use:  how many times does the word "coral" show up?  


How would we modify this code to count the most popular words by book? What about by each chapter within a book?  





**sentiment analysis**  
There are many ways that we can now analyze this tidy dataset of text. One example is we could do a sentiment analysis (how many positive and negative words) using get_sentiments(). An important note: I was not an English major and I know there are many different lexicons, but I know nothing about them. Look at the help files if you want to go deeper into this...  
```{r}
sent_word_counts <- tidy_books %>%
  inner_join(get_sentiments()) %>% # only keep pos or negative words
  count(word, sentiment, sort = TRUE) # count them
head(sent_word_counts)[1:3,]
```
inner_join only keeps things found in data frame that you're bringing in.  
get_sentiment lexicon counts "miss" as a negative  



Now, think about how we could do this with science? Instead of get_sentiments(), you could use an inner_join with a vector of keywords that you are searching for.  
--> put in a data frame and find and count key words we're looking for in abstracts.  


Let's plot it.  
We can now use ggplot to visualize counts of positive and negative words in the books  
```{r}
sent_word_counts %>% # data cleaning
  filter(n > 150) %>% # take only if there are over 150 instances of it, filter n
  mutate(n = ifelse(sentiment == "negative", -n, n)) %>% # add a column where if the word is negative make the count negative, if sentiment says its negative, make n negative if not keep it positive
  mutate(word = reorder(word, n)) %>% # sort it so it gows from largest to smallest
  ggplot(aes(word, n, fill = sentiment)) + # now make plot
  geom_col() +
  coord_flip() + # flip axes 
  labs(y = "Contribution to sentiment")
```


#### Make a wordcloud  
Use the {wordcloud} package to make an interactive word cloud  
hover or press the word it shows you how many times it appears in the book (n)

```{r}
words<-cleaned_books %>%
  count(word) %>% # count all the words
  arrange(desc(n))%>% # sort the words in descending order
  slice(1:100) #take the top 100
wordcloud2(words, shape = 'triangle', size=0.3) # make a wordcloud out of the top 100 words
```


**Today's totally awesome R package**
{ggirl} (gg in real life)
Have you ever made a plot that you love so much and thought, "I want to send this to someone!" Well, now you can! Turn your ggplots into a postcard.
(Note, I wouldn't be mad if random postcards of ggplot showed up in my mailbox...)

Check out [ggirl](https://jnolis.com/blog/introducing_ggirl/)  









_________________________________________________________________________________________

## Week 8a Lecture: Advanced Plotting    

[Lecture Slides](https://raw.githack.com/OCN-682-UH/Fall_2025/main/Week_08/16_AdvancedPlotting.html#1)  
[Required Reading r4ds](https://r4ds.hadley.nz/regexps.html)  


### Introduction  

**Outline of class**  

Advanced plotting:  

* {patchwork} - bringing plots together  
  * not just using facet  
* {ggrepel} - repel your labels on your plots  
  * not all on top of each other and overlapping  
* {gganimate} - add some animations to your plots  
* {magick} - photo processing 

I am just going to give you a little taste of what each of these packages can do. Please check out the documentation for each to delve deeper.  


### Load Libraries  

```{r}
library(tidyverse)
library(here)
library(patchwork) # for bringing plots together
library(ggrepel) # for repelling labels
library(gganimate) # for animations
library(magick) # for images
library(palmerpenguins)
```


### Read Data
```{r}
glimpse(penguins)
```


#### Patchwork  
Easily bring your plots together  

* cowplot and ggrid also can be used but Nyssa likes patchwork the best  

Two simple plots from Palmer penguin dataset:  
```{r}
# plot 1
p1<-penguins %>%
  ggplot(aes(x = body_mass_g, 
             y = bill_length_mm, 
             color = species))+
  geom_point()
p1
```

```{r}
# plot 2
p2<-penguins %>%
  ggplot(aes(x = sex, 
             y = body_mass_g, 
             color = species))+
  geom_jitter(width = 0.2)
p2
```


Bring the plots together using simple operations.  
Want them to be together in one subplot  
```{r}
p1+p2 + # puts them together
  plot_layout(guides = 'collect') + # group the legends
  plot_annotation(tag_levels = 'A') # add labels (A, B)
```


Put one plot on top of the other.  
```{r}
p1/p2 + # dividing them puts one on top of eachother
  plot_layout(guides = 'collect')+ # guides is another word for legend
  plot_annotation(tag_levels = 'A') # adds a tag (roman numerals and numbers too)
```

So many cool ways to bring together and modify plots. For more info see the many [vignettes here](https://patchwork.data-imaginist.com/articles/patchwork.html).  


#### ggrepel  

Easy and clear labels for plots.  

Use the mtcars dataset that comes with it. It is data on cars. Automatically comes with ggplot  
View(mtcars) # cars and mpg data and weights of cars  


Simple Plot  
```{r}
ggplot(mtcars, aes(x = wt, # weight
                   y = mpg, # miles per gallon
                   label = rownames(mtcars))) + # every point has a label, extract row names
  geom_text() + # takes whatever you put into label and creates a text label at every x and y coordinate
  geom_point(color = 'red')
```

Repel the labels  
```{r}
ggplot(mtcars, aes(x = wt, 
                   y = mpg, 
                   label = rownames(mtcars))) +
  geom_text_repel() + # repel them away from the points for readability, attaches line from text to the point
  geom_point(color = 'red')
```

Use label function  
```{r}
ggplot(mtcars, aes(x = wt, 
                   y = mpg, 
                   label = rownames(mtcars))) +
  geom_label_repel() + # repel them with a box around the text, choose text or label depending on the aesthetic you want
  geom_point(color = 'red')
```

More cool things you can do with [ggrepel here](https://ggrepel.slowkow.com/articles/examples.html).  



#### gganimate  

Make your figure an animation!  

Let's go back to our penguin plot, but animate the figure by year. This has all the years. Our static plot.  
```{r}
penguins %>%
ggplot(aes(x = body_mass_g, 
            y = bill_depth_mm, 
            color = species)) +
  geom_point()
```
Say you want to highlight how relationships change from year to year. So animate points from first year to last year.  
Add a transition. 
```{r}
#| output: false
#| eval: false
penguins %>%
ggplot(aes(x = body_mass_g, 
            y = bill_depth_mm, 
            color = species)) +
  geom_point() + # add a transition here
  transition_states(year, # what are we animating by, in this case it is year
     transition_length = 2, #The relative length of the transition.
     state_length = 1) # The length of the pause between transitions
```
Every new animation is by year. 
How long does it take to go from one year to the next (2 seconds in this case)  
The pause between transitions is 1 second.  



Change the *ease* aesthetics  
ease_aes --> change how it moves from one state to the next  
```{r}
#| output: false
#| eval: false
penguins %>%
ggplot(aes(x = body_mass_g, 
            y = bill_depth_mm, 
            color = species)) +
  geom_point() + # add a transition here
  transition_states(year, # what are we animating by
     transition_length = 2, #The relative length of the transition.
     state_length = 1) + # The length of the pause between transitions
  ease_aes("bounce-in-out") # change the ease aesthetics
```

Some examples:  

* linear (default)
* bounce
* sine
* circular
* many more...


Add a transition title to labs() argument and save it  
```{r}
#| output: false
#| eval: false
penguins %>%
ggplot(aes(x = body_mass_g, 
            y = bill_depth_mm, 
            color = species)) +
  geom_point() +
  transition_states(
     year, # what are we animating by
     transition_length = 2, #The relative length of the transition.
     state_length = 1 # The length of the pause between transitions
   )+
  ease_aes("sine-in-out") # +
#  labs(title = 'Year: {closest_state}') + # transition title 'Year: {}' colon tells you want you want it to say, whatever is in bracket is the argument that is used to say what state you are in right now

```
To save:  
anim_save(here("Week_08","Output","mypengiungif.gif")) # save it as a .gif and portable

'Year:' would stay static.  
The *{ }* would say what you want it to be in  


More things to do with [gganimate here](https://gganimate.com/index.html).  




#### magick  

*Advanced image processing*  
Useful for:  

* converting photos from grayscale or binary  
* manipulate images  
* put images on top of plots.  

Put a penguin in it.  
Read in an image of a pengiun (can be on your computer or the internet).  
  either read it in from your output folder or put the link.  
Needs to be in .png or .jpg
```{r}
penguin<-image_read("https://pngimg.com/uploads/penguin/pinguin_PNG9.png")
penguin
```


To put it on a plot, first need to save your plot as an image.  
```{r}
penguins %>%
ggplot(aes(x = body_mass_g, 
            y = bill_depth_mm, 
            color = species)) +
  geom_point()

# ggsave(here("Week_08","Output","penguinplot.png"))
```

Read in the plot as a magick image and make a composite plot  
```{r}
penplot<-image_read(here("Week_08","Output","penguinplot.png")) # read png file back in using image_read
out <- image_composite(penplot, penguin, offset = "+70+30") # put them on top of each other, background goes first, second layer goes next, offset tells you where you want penguin to be
out
```

Can do this with gifs too  
```{r}
# Read in a penguin gif
pengif<-image_read("https://media3.giphy.com/media/H4uE6w9G1uK4M/giphy.gif") # found on internet, use image_read
outgif <- image_composite(penplot, pengif, gravity = "center") # move the image (this puts it in middle of plot)
animation <- image_animate(outgif, fps = 10, optimize = TRUE) # put it in image animate, 10 is low quality so doesnt take up much space on computer
animation # can save with animation save as well
```

More [magick plotting](https://cran.r-project.org/web/packages/magick/vignettes/intro.html) here.  


**Today's totally awesome R package**  
Sourdough recipes in R!  

remotes::install_github("andrewheiss/sourrr")
library(sourrr)
build_recipe(final_weight = 900, hydration = 0.75)













_________________________________________________________________________________


If i need it...

No homework 
Week 08 Homework












